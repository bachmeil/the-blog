---
title: Limitations of D for Academic Research
layout: post
---
D could have major appeal to academic researchers needing to do numerical computing. There are currently some limitations that limit the marketability to academic researchers. The alternative languages I have in mind are R, Python, Matlab/Octave, and Julia.

Corporate adoption is the clear goal of the D Language Foundation. I see it as a tough sell for reasons that have been discussed to death. Academic research requires a completely different feature set: it should be easy to learn, not complicated to write and read, trust that the code will be correct, and fast enough. The last has become more important recently due to large datasets and the heavier use of computationally-intensive methods such as Bayesian inference.

In spite of D's potential, there are some limitations that are a disadvantage. Here are some of them in no particular order.

- Limited operator overloading. I've read Walter's position and it's true that you can abuse this feature. That comes with a caveat. To do it right, you still need to provide enough operators to do what needs doing. You can't just say "those are the operators I need, so that's what's available". A prominent example is matrix multiplication. You need regular matrix multiplication and element-by-element matrix multiplication. Matlab and Julia provide `*` for the former and `.*` for the latter. With R, it's `*` for element-by-element and `%*%` for regular. You can't write a sensible operator for both in D. The best I've been able to come up with is to do something like this: `mat1.el * mat2`, where `el` returns a different type, triggering element-by-element multiplication. I think that would be confusing for someone coming from Matlab. Not as confusing as the alternative `mat1 <<= mat2`. The Matlab syntax wouldn't work but something like `**` would. (This isn't a syntax proposal.) Other cases where it's needed are for sequences, either `2..5` or `[2..5]`, and when you want all rows or columns of a matrix/array, `x[,3..7]`, `x[:,3..7]`, `x[..,3..7]`, or similar. This is a *very* important issue, one that's generally not understood by the systems programming languages folk.
- dub.json needs to disappear. This one's awful for academic researchers. Create a project to do a few calculations? Create a configuration file in JSON? To calculate descriptive statistics? Dub should be used to install packages and hold information about the packages (dependencies and such) but there's no reason for users to write a dub.json file. Make `-i` the default. Look in the current directory and in the package installation directory/directories.
- Windows support for calling dynamic libraries is messy. Import libraries have given me nothing but trouble. Manually importing functions from DLLs on Windows has worked well. What doesn't make much sense is why I have to do that. I've written functions that handle the boilerplate. With ImportC, you should be able to feed the compiler some C function declarations and have it create the necessary bindings for you. Even better would be using Dub to install a package that creates the bindings for you and stores the necessary metadata in the configuration file. Someone using R would never have to mess with any of this - it's all handled by the package management system to the point that most Windows users have never heard of a DLL. There's no reason we can't have the same experience.
- The hassle of creating dynamic libraries called by other languages. The compiler is very easily able to make this easy - I know, because I've already done it with metaprogramming. What I have in mind is a set of `extern(*)` declarations: `extern(R)`, `extern(Matlab)`, etc. All you need to do is write a wrapper function that converts the arguments of a D function into types that can be understood by the other language. When I say I've done it, I mean I wrote a library that takes a D function with signature `double foo(double[] x, int[] y)` and creates the function `extern(C) SEXP foo(SEXP x, SEXP y)`. The .so or .dll can be loaded by R and called like any other R function. This would be a killer feature for D.

I don't view these as particularly difficult to implement:

- Change 1 would require adding new operators to the language.
- Change 2 would require scanning the file for import statements and constructing an appropriate compilation command.
- Change 3 would require more thought, but I've already been doing most of this using D's metaprogramming.
- Change 4 is something I've already done for R. All that's needed is to convert `extern(R)` declarations to `@extern_R` and add a mixin statement. Other languages would require figuring out interop.